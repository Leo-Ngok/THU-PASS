# PA32 报告

## Not Found

### 1. 读题

找一个最短的01串，它不会是最长为$16777216$ 的01串的子串。

### 2. 解题思路

长度为1的01串共有两个，长度为二的共有$2 ^ 2 = 4$ 个，$\cdots$ ，长度为23的01串共有 $2 ^ {23} = 8388608$ 个，24的01串共有 $2 ^ {24} = 16777216$ 个， 因此对于这题的数据规模，答案长度不会超过24位。

对于某一个01串，摘掉该串的首位与末尾，仍然是出现过的，都要把那些串记录，因此可以利用递归把那个串设为存在，把它去掉头尾之后的子串也同样记录。

由于相同的串所对应的子串都是一样的，因此对于已经被记录的串，就不用重新记录它的子串了，这就可以降低运行时间。

### 3. 实现

为了节约空间，可以把01串表示成某个数的二进制表示。

由于答案不会比24长，因此对于长度大于24的01串，每读入一位，就可以把本来的串的首位舍去。

为了区分不同长度的前缀0，在实际操作的时候，统一把01串的最高位的前方加上1，这就相当于保存01串的二进制表示是从2 = $(10)_2$ 开始的，把所有的长度小于25 的01串表示，需要$2 ^ {25}$位。

如果利用位运算的特点，就可以减少保存状态的空间。

每个 `long long` 对应8个字节，所以要把所有01串表示，需要大小为 $2 ^ {19}$ 的 `long long` 数组。

（2）中提及的递归函数的实现

```c++
void fill(long long STATE, size_t len) {
    if(24 < len) len = 24;
    long long temp = (1LL << len) | STATE;
    if(_bit_set.get(temp)) 
        return;
    _bit_set.set(temp);
    if(len <= 1) 
        return;
    fill(STATE >> 1, len - 1);
    fill(STATE & ~(1LL << (len - 1)), len - 1);
}
```



