# PA42 报告
## Game
### 1. 题意

求从结点1到结点n的道路，使得经过那些道路的时间总和最小，同时输出道路个数。

### 2. 解题思路

分为两个部分：

1. 求最短路
2. 统计最短路的可能性个数

以下分别对这两个部分展开讨论。

#### 2.1 最短路

把输入的无向边，等价为两条方向相反的边，边权为终点的通关时间。

把这样的图从结点 $1$ 到的结点 $n$ 的最短路求出，加上结点 $1$ 的通关时间就是答案的时间部分。

加上通关时间为正，可以使用 Dijkstra 算法求图的最短路。

#### 2.1.1 Dijkstra 算法

思想：对于所有的结点，维护一个从结点 $1$ 到该点的最短路长度。

从结点 $1$ 出发，对于当下被选的结点，如果可以通过该点的邻边，走到下一个结点，且距离更短，就更新那个被维护值，然后选一个没有被选且维护值最小的点，直到所有的点都被选。

伪代码：

```
Mark the working value of node 1 as 0, and choose node 1 as the current node i.
Mark other nodes as infinity, 
Mark node i as visited.
For chosen node i, for all neighbors j of i,
	working value of j = min {working value of j, working value of i + w(i,j)}
Find a node such that it is not visited and has smallest working value.
If that node exists: 
	assign i to be that smallest node, and go to line 3. 
Else:
	return working value of n
```

如果在第5行的实现方式是遍历所有的结点，上述算法的时间复杂度为 $O(n^2)$ ， 这也是我在当初，在手写堆的实现尚未成熟的时候交的代码，得 50 分。

如果是利用优先队列求未遍历，距离最短的结点，时间复杂度可以优化。

遍历所有结点需时 $O(n) $ ，每次取结点，把插入、删除的时间也算上，为 $O(\log n) $ ，遍历每条边，用时 $ O(m) $ ，总体时间为 $O(n + m \log n) $ 。

#### 2.1.2 优先队列

上文提到的优先队列，是用小根堆实现的，堆存放的是结点下标，堆顶存放 ``` working value ``` 最小的结点下标。

对于连通图，所有结点都有至少一次进入堆的机会，因此能遍历所有的结点。



### 2.2 统计最短路的个数

上述算法可以诱导那个有向图的一个连通子图，对于那个子图的所有的边，边权都等于终点与起点的 ```working value``` 之差。如此一来，那个子图实际上是只有所有最短路的图。由于每条边的边权为正，那个子图必然是有向无环图。因此，就可以用递推的方式，求出道路个数，方法是加法原理和乘法原理，具体如下：

0. 令结点 $n$ 的递推值为 1。

1. 首先把那个子图的所有的边选出，且同时记录每个结点的入度。

2. 反复的把入度为零的结点加入到某个序列，把它的关于子图的邻点的度减一，直到所有邻点入列。（拓扑排序）
3. 从序列的后部开始，计算结点的递推值，为它的在子图的所有邻点的递推值之和。

最后输出结点一的递推值，即为道路个数。

