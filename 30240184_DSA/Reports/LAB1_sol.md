# LAB1 报告

## Zuma

### 01.cpp

#### "Runtime Error."

```
15 void play(int rank) {
16    ...
17    if (size >= 3) {
18        a.erase(left, size);
19        play(left - 1);
20    }
21 }
```

第19行 当 ```left == 0 ```  的时候，```play(int)``` 以 ```rank = -1 ``` 进入，就会出现 ``` a.at(-1) ``` 的情况，属于数组越界。

测试样例的构造：对祖玛串最左侧发射珠子，使得最左侧出现消去的情况。

### 02.cpp

#### "Runtime Error"

类似第一题，当字符串 ```a``` 为空，读取任意元都是数组越界。

测试样例的构造： 长度为二的字符串，由同一个字符组成，然后把那个串发射同色珠子消去。

### 03.cpp

#### "Time Limit Exceed"

第18行的```std::string::erase(int, size_t)``` 函数的复杂度为 $$O(|S|)$$，34行的```std::string::insert``` 同理，只要初始串足够长，就可以卡时间复杂度。

测试样例的构造： 先在数据范围允许范围内，构造极长的串，作为第一行的输入，然后不停的在最前方插入，如：

``` ("AB") * k ```， 其中 $$k$$ 是一个比较大的，而且比题目数据范围的一半小的常数。

接着输入 $$t(\leq m)$$ 行，```0 c```， ```c!='A'```, ```c!='B'``` .

### 04.cpp

#### "Wrong Answer"

第12行把范围以外的第一个位置也算进去消掉。

样例： 

```
ABBC
1
2 B
```

正常输出 ```AC```, 04.cpp 输出 ```C```.

### 05.cpp

#### "Wrong Answer"

忽略了空字符串的情况。

样例构造：第一行为空的任意输入。

### 06.cpp

#### "Wrong Answer"

调整分块数组的时候，忽略了在分块满的时候，应该要重新分块，第74行用```memmove```的时候会把后方数组的值覆盖掉。

样例构造：

先输入长度为两倍（块的）初始容量的串，然后不停的在前方数组塞珠子，一直到第一个块塞满，再塞一颗珠子就会把第二个块的首项覆盖。

样例：(python 语境)

```
("CD") * 2048 + (AB) * 2048
2049
0 E //2049 行
```

### 07.cpp

#### "Wrong Answer"

对于搜索消去珠子范围，在左搜的时候，如果左方分块恰好为空，就把更前方的块忽略了。

```
 // 计算需要消除的开区间 (l, r)
...
while (1) {

	  while (l.first >= 0 && get(l) == ch) {
		...
       if (l.second < 0 && l.first >= 0) { //错误行，应改成循环
            l.first--;
            if (l.first >= 0)
              l.second += plen[l.first];
          }
        }
    ...
  }
```


样例构造：

对初始祖玛串，先以（块的）初始容量个字符填满，要求其某个后缀与第三个分块对应串的某个前缀能对消。

接着构造第二个分块的串。

构造第三个分块，满足前述要求。

样例：

```
("AB") * 1023 + "AA" +("YYWW") * 512 + "CCAA"
3
4096 W
2048 W
2050 B
```

### 08.cpp

#### "Wrong Answer"

忽略了连消的情况。

样例构造： 第一行是存在连消可能性的串。第三行开始，试图发射珠子触发连消。

### 09.cpp

#### "Runtime Error"

对第135行，消去块范围在同一块，且存在多个块的时候，会出现长度为负值的情况：
$$
len = plen[r.first] - r.second = plen[l.first] - r.second = l.second - r.second + 1
$$
有可能是负。

对137行由于```size_t``` 是memmove 的最后一个输入，memmove会存取非常大的位置，导致溢出。

样例构造：

弄一个长度可以初始覆盖多个块的数据，在其中一个消去珠子。

样例：

```
"T" + "RREE" * 511 + "RRWD"
1
1024 E
```

### 10.cpp

#### "Wrong Answer"

第147行，把首个块长度清零了，但这并不见得首块被全消，就是循坏起点错了。

样例构造：

弄一个串，头部存在不连续的前缀，后面的部分可以以“链式反应”消去。

样例：

```
"T" + ("RREE") * 600 + "RRGA"
1
1046 R
```

