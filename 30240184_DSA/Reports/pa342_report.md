# PA34-2 报告

## Kidd

### 1. 读题

实现线段树的区间更新，区间查询。

### 2. 解题思路

本题所有区间，以左闭右开形式保存，每个结点保存该结点区间的线段个数与以区间长度的积。

这题只有区间更新、查找两项，因此应把所有插入区间的端点记录。与此同时，记录所有的操作。

读完所有的操作之后，就把端点排序并去重，用时$O(n\log{n})$。

每一个线段树结点，都记录了那个结点所对应的线段两端。由树的特点，建树时间为 $O(n)$。

对于每一次操作，如果那个点有懒惰标记，就对那个点的值加上那个区间的长度，并把懒惰标记转移到它的子结点。

对于每一次插入线段，

1. 如果某个结点对应区间完全包含在内，就把那个结点存的值加上那个端点对应的区间，对它的子结点（如有）加上懒惰标记。

2. 如果某个结点，如果与插入区间不相交，就直接不处理那个结点。
3. 否则，那个端点就一定是跟那个区间部分重合，这就应该先算它的两个子结点，把字节点保存的值，转移到自己记录的值。

对于每一次查询，

1. 如果结点区间被部分包含，就递归算它的子结点。
2. 如果子结点被完全包含，就直接返回子结点保存的值。
3. 如果不相交，则递归查找函数返回0.
4. 如果到了树叶
   1. 树叶区间被完全包含在内，则同 2.
   2. 否则，当返回就对结点保存的值，乘以查询区间与树叶结点重合的部分的长度，除以结点的长度。

查找、更新都是 $O(\log n)$.

### 3. 实现

方式与带有懒惰标记的线段树基本一致，以下给出线段树结构体的声明：

```c++
struct node {
    long long left, right;
    long long count;
    long long tag;
    bool leaf;
}Nodes[MAXM];
```

tag 是懒惰标记，count 是结点保存的值。